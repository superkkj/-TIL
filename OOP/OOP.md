# OOP


## 객체지 ?

 + 좋은 코드를 짜기 위한 방법
 + 좋은 코드를 쓰는것


## 좋은 코드?

 + 변경하기 쉽고
 + 이해하기 쉬운 코드
 + 그러나 어렵다..


## 좋은  코드를 쓰려면 나누고 묶자.

 + 복잡한 프로그램을 작은 단위로 나누고 묶어 정리
 + 추상화 구조화.
 + 넥스스트 스텝에서. 코딩을할때 가장 작은단위부터 프로그래밍한게 생각이나네..


## 객체지향은 코드를 정리하는 방법중 하나.

 + 어떻게 하면 코드를 더이해하기 쉽고 변경하기 쉽게 정리할 까? 의 답 중 하나.


## Why ? OOP? 에서 시작 해보자

 + 도대체 왜 ? 객체지향을 써야함?
 + 좋은 코드 쓰고 .. 좋은 코드란 이해하기 쉽고 변경 하기 쉬운 코드.
 + 좋은 코드를 만드려면 일정한 기준을 가지고 코드를 구조화 하고 저 ㅇ리
 + 객체지향은 코드를 구조화 하고 정리하는 방법 중 널리 쓰이는 효과적인 방법

 + 그러면.. 어떻게 코드를 정리함?



# 엘런 케이가 말하는 객체지향 프로그래밍의 본질

 + 소프트웨어를 구조화하는 방법을 연구하는 엘런케이..

## 행동을 기준으로 코드를 묶을 때

 + 영화 티켓을 예매하는 프로그램.
 + 변경가능한 공유데이터가 많아져서 다른 프로시져가 조작하다가 버그가 발생할 가능성이 생김.



## 독립된 개체가 메시지를 통해 소통한다면..

 + 독립된 객체를 각자 정의
 + 독립된 개체는 프로시져 추상화도 같이쓰이지만 데이터와 프로시져가 더 큰단위로 묶임.
 + private 키워드를 써서 외부에서는 데이터를 건드릴수 없게! (공유데이터 문제 해결.)


## 메시지

 + 개체에게 메시지를 보내 자신이 직접처리하지않고 개체에게 메시지를 보냄(함수 호출이라고 생각되지만 메시지를 보낸다 처리해줘!)
 + 메시지를 받는 쪽은 어떻게 처리할지 직접 결정하게 만듬 ( 각자의 역할. 단일 책임의 원칙!)
 + 함수 호출은 같은 행동과 연결됨 / 메시지 경우 같은 메시지를  처리방법이 그때마다 달라짐 (개방 폐쇄의 원칙?)
 + 메시지를 다른 곳에 위임 -> 누가 그걸 처리하듯 결과만 제대로 가져와 
 + 메시지를 통 한 소통..


## 메시징 캡슐화 동적 바인딩.이 합쳐 질때

 + 관련 있는 데이터와 프로시져를 찾아서 묶고 다른 객체가 내부를 못 건드리게 (캡슐화) 
 + 다른 객체의 데이터나 프로시져 필요할때 메시지 요청 . 메시지를 받는 객체는 스스로 처리방법 선택 (메시징)
 + 메시지를 받는 객체는 그때 그때 달라짐 (동적 바인딩 )

 -> 변경 가능한 데이터 최소로 줄어듬 -> 구현 부분 쉽게 바꿈 -> 메시지를 실제 처리하는 객체 쉽게 바꿈.. (순서대로 123) 여러개의 구현체를 만들어 작업중 바꾼다..
 

## 객체 지향의 본질..

 + 클래스나 객체의 초점이 가게된다...
 + 캡슐화 .. 메시징 .. 동적 바인딩.
 + 객체를 만들었다고 다가 아님, 객체들이 어떻게 협력해서 전체를 이루는게 중요.
 + 메시지는 결국 누구한테 위임할지 결정해주는 타입 계층.
 + 객체에서 메시지를 수신하는 부분만 따로 떼어내서 정의한 게 인터페이스
 + 그 때 그 때 동적 바인딩 해야되니 객체의 생성과 사용을 분리.
 + 객체를 묶고 이름 지을때 최대한 실제 세계와 비슷하게 만들면 이해하기 쉽다. 그래서..'도메인(간단히 말하면 해결하고자 하는 문제의 영역  요구사항.. 문제 영역)'


