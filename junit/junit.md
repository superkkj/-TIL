# junit 



## 단언 3.1


  + assertTrue 
  + assertThat - 값 비교



## hamcrest 

 + 잘 활용하면 테스트 코드 표현력이 더 좋아진다.
 + equalTo  - equals() 메서드 사용해 어떤 타입이든 비교가능. 
 + 기존 사용했던것처럼 assertThat(a).equalTo(a) 이런식으로 표현 하면 될 듯.

### CoreMatchers Class


 + is 
 + assertThat(account.getName(), is(equalTo("my big fat acct")));

 + not
 + assertThat(account.getName(), not(equalTo("plunderings")));


 + isCloseTo - 부동소수점 비교 매처
 + assertThat(2.32 * 3, closeTo(6.96, 0.0005));


### hamcrest 매처 사용시 

 + 객체 타입 검사 
 + 두 객체 참조 같은 인스턴스 검사 등..

## 단언 설명

 + assertThat에 메세지를 포함하여 테스트가 가능.
 + assertThat("account balance is 100", account.getBalance(), equalTo(50));


## 예외 기대

 + 에너테이션 방식
 + Try/catch 
 + ExpectedException 규칙.


### ExpectedException

 + @Rule
 + public ExpectedException thrown = ExpectedException.none();
 + 이런식으로 룰로 만들어 예외를 기대 할 수 도 있다 기존 junit5쓰면 thownBy를 주로 썻는데 음..


# 테스트 조직


## AAA 테스트 일관성 유지

 + 준비(Arrange) / 실행(Act) / 단언 (Assert)


## 동작 테스트 vs 메서드 테스트

 + 테스트는 클래스 동작에 집중해야지 개별 메서드 테스트한다 생각하면 안됨

## 테스트와 프로덕션 코드의 관계

 + 테스트는 프로덕션 코드와 분리를 해야 된다.


### 데스트와 프로덕션 코드 분리

 + 테스트를 별도 디렉터리로 분리하지만 프로덕션과 같은 패키지에 넣기 - 현제 IDE 디폴트 동작
 + 테스트를 별도의 디렉터리와 유사한 패키지에 유지하기 - > test - test -> ...   의도적으로 이렇게 설계하는 경우도 잇다.



### 내부 데이터 노출 vs 내부 동작 노출

 + 테스트 코드를 작성할때 공개 인터페이스만 사용하는게 좋다?
 + 공개가 아닌 메서드를 테스트 코드에 사용시 정보 은닉에 위반되기 때문!
 + 그러나 비공개 코드 호출하는 테스트 자체는 구현 세부사항과 결속을 가지게되 세부 사항이 변경되면 테스트가 깨진다.
 + 이런게 쌓이면 나중엔 리팩토링하기도 꺼려지고 정체된 코드가 되버림.



## 단일 목적 테스트의 가치

 + 한 테스트의 여러개의 검증을 넣는것은 지양해야된다.
 + 실패할경우 실패한 테스트 이름이 주어지는대 여러가지가 있다면 검증하기 쉽지않음.


## 문서로 서의 테스트

 + 클래스에 대한 지속적이고 믿을 수 있는 문서 역할을 해야함.
 + 일관석있고 설명이 들어가있는 테스트 이름을 정하자 ( 근대너무 길어지는경우도 있는거같아 별로인거같다.)
 + given when then 행위주도 개발 양식도 추천하고 있따.



## Beforㄷ / After

 + @BeforeClass라는 어노테이션도 있다 참고



# 좋은 테스트의 Firest 속성

 + First : 빠르고 고립되었으며 반복가능하고 스스로 검증가능한 적시의 뜻.


## 빠르다.

 + 외부 요소를 배제시키고 고립되게 테스트 
 + 단위 테스트 시간이 오래걸린다면 (양이 많을경우 10~30분) 잘못된 방향이다.
 + 의존 성을 줄이는 것부터 시작해야 된다.

 + 정리하면 클린 객체 지향 설계 개념과 맞출수록 단위테스트 작성은 쉬워짐


## 고립

 + 최대한 작은 양의 동작에 집중할수 있게 테스트 작성하자
 + SRP 법칙에 따라 다른이유로 테스트가 깨진다면 분리를 하는것을 고려해야 한다.


## 반복

 + 테스트는 항상 결과가 같아야 한다.


## 검증

 + 테스트는 어떤설정 단계든 자동으로 수동으로 검증해서는 안됀다.
 + 스스로 검증 가능하고 준비도 해야됨



## 적시에 사용

 + 언제라도 단위 테스트를 작성할 수 있어야 한다.



# Right-BIICEP : 무엇을 테스트 할까? -06 


 + 경험이 많지 않다면 스스로 짠 코드에서 버그를  찾아내기는 쉽지않다.


 + Right : 결과가 올바른가?
 + B: 경계 조건이 맞는가? 10이상 20 이하라 했을때 9 나 19 20 이런걸 넣어서..
 + I: 역 관계를 검사할 수 있는가?
 + E: 오류가 강제로 일어나게 할 수 잇는가?
 + P: 성능 조건 은 기준에 부합하는가?


## 결과가 올바른가?


 + 단위 테스트를 할 때 행복경로만 측정하면 안됨
 + 고객의 요구는 언제든지바뀔수 있다 그때마다 변경함
 + 명확한 답이 있을때 코드를 작성. 혹은 최선의 답이 있을때 작성하고 추후 변경 

## 경계 조건은 맞는가?

 + 정규식이나 어떤 형식 , 오버플로우를 일으키는 값, nulll, 중복 범위를 벗어나는 값 등..
 + 이런 사례들을 테스트로 걸뤄줘야된다.
 + 예외를 던저준다던지.. 중복값 검사 등..

## 경계 조건에선 CORRECT를 기억하라. 

 + 값이 기대한 양식을 준수하는가?
 + 값의 집합이 적절하게 정렬되거나 되있지않거나
 + 범위에 맞는 최솟값 최댓값에 있는가
 + 코드 자체에 통제할 수 없는 외부 참조를 포함하는가
 + 값이 존재하는가 아니면 널인가?
 + 정확한 값이 충분이 들어가 있나
 + 모든것이 순서대로 일어나는거 정확한 시간에?

 + 이 부분은 어렵다.. 흠 . .


## 역 관계를 검사 가능한가?

+ 곱셉 을 나눗셈으로 검증하는 방법 등..
+ 딱히 예시가없는거같은데 생각해야되는 부분인듯 .
+ 책에 나온 예시는 리스트에 객체를 추가함
+ 하나씩 꺼내서 제대로 들어가 있는지확인?


## 다른 수단을 활용해 교차 검증이 가능함?

+ 자바에서 제공하는 함수로 검증하는등.. Math.sqrt 성능은 느리지만 정확한 참값을 보장하면
+ 좋은방법임



## 오류조건을 강제로 일어나게 할 수 있는가?

 + 행복경로가 있따면 불행한 경로도 있다.
 + 메모리가 가득찰때 / 디스크 공간이 가득찰때 / 네트워크 가용성 및 오류들
 + 음... 코드작성할 때 단위로 모든걸 차단해서그런가 예상하지못한 단어들만  나온다.




## 성능 조건은 기준에 부합하는가?

 + 단위 테스트를 통하여 병목지점이 생기는 부분 문제가 생기는 부분을 찾아야 한다.
 + 단위 성능 측정을 잘사용하려면? 변경 사항을 만들 때 기준점을 잘활용해야된다 .. 이게 뭐지?
 + 람다를 정통적인 원래 기법으로 만든다던지..
 + 단위 테스트 경과 시간을 측정하는 성능 테스트를 작성해보자 평균 시간을 구해보는 의미.
 + 주어 진 코드를 덩어리로 분리하고 실행하자.




# 경계 조건 : CORRECT 기억법

 + 경계조건들에 관계에 결함에 따른것을 미연에 방지해보자.


## 준수 Conformance

 + 처음 입력될때 검증이 된다면 많은 곳에 쓰여지는 필드가 더 이상 검사하지 않아도 된다
 + 각 경계조건이에서 어떤일이 일어나는지 테스트 코드로 작성해야 한다.


## 순서 Ordering

 + 순서 잘지키기 딱히 뭐없음..

## 범위 Range

 + 객체로 감싸서 내부 에서 일정 범위가 넘어가면 예외던지기(next step에서 하던방법)
 + 불변성 검사하는 사용자 정의 매처를 사용하기 딱히...
 + 불변 메서드를 내장하여 범위 테스트 이것도 딱히..

## 참조 Reference


 + 범위를 넘어선거를 참조하나?
 + 외부 의존성은 뭔가?
 + 특정 상태에 있는 객체를 의존?
 + 반드시 존재해야 하는 그 외 조건

 + 자동차 운행중 정지 일때 기어 변경이 가능한지에 대한 예시. 흠 이해가 어렵다


## 존재 Existence


 + 주어진 값이 존재함?


## 기수 Cardinality

 + 울타리 기둥 오류라는 예제로 개수를 잘 세어 보고 테스트를 해야됨.
 + 기수를 사용하면 일부 OR 없음 아니면 다수. 0 1 N 이다.
 + 


## 시간 TIME

 + 상대적 시간 (시간 순서)
 + 절대적 시간 ( 측정된 시간)
 + 동시성 문제들

 + Login 은 Logout 앞에 , read()앞엔 Open() ghcnf godi ehla.
 + 호출 순서가 안맞으면 ? 
 + 타임 아웃으로 보호되지않는 조건을 찾아보자.


# 깔끔한 코드로 리팩토링

## 메서드 추출

 + 메서드 안에 복잡한 로직은 따로 메서드로 분할을 한다 (인덴트를 지키기위해 메서드 분리하는 방법과 같았다.)
 + 복잡성을 고립시키기.

## 메서드를 위한 더 좋은집 찾기

 + 위에 고립된 함수를 적절히 역할에 맡는 클래스로 옴기기
 + 예제에선 두개의 파라미터를 받는 메서드를 파라미터 하나의 클래스에 옴겨서 역할을 다하게 함.


## 자동 및 수동 리팩토링

 + 위에 과정을 거쳐 코드를 최대한 줄이기.
 + 코드는 좀더 명확해지고 읽기 쉬워진다.

## 과한 리팩토링?

 + 리팩토링을 위에서처럼 하다보면 함수 가 여러갈래로 나눠지고
 + 예제처럼 포문이 3개나 생길수 있다.
 + 그러나 코드가 좀더 명확해지고 어떤일을 할지 이해하기 쉬워지고
 + 성능적으로도 상상하는 것만 큼성능은 나쁘지 않을 수 있다.
 + 성능이 즉시 문제 안돼면 코드를 깔끔하게 유지하자.


# 더 큰 설계 문제

 + 단일 책임원칙 위주에 맞춰서 진행
 + 객체 하나의 너무 많은 책임을 지면 코드가 복잡해진다 .



## 정리

 + 단일 책임의 원칙에 따라 클래스를 분리하는게 좋다
 + 한 클래스가 너무 많은 부담을 지면 결과적으로 많은 에러와 혼란을 줄수 있음.
 + 클래스에 맞지않는 변수 어울리지않는 필드는 따로 지역변수로 빼둔다.
 + List 같은건 일급 객체로 분리해서 빼둔다. (래핑) 넥스트 스탭에서 배움
 + 여기서도 객체끼리 서로 메세지를 보내지 따로 겟 셋은 하지 않는다. 신기하다. 
 + 객체지향적으로 코드를 짜면 결국 테스트하기 좋은 코드가 되는거 같다.


# 목 객체 사용


## 번거로운 동작 스텁 대체

 + 테스트 용도로 하드 코딩한 값을 반환하는 구현체를 스텁이라 함.


## 스텁 -> 목으로 변환

 + 스텁에 지능을 넣어 조건문도 걸고 한다. 하지만 실패하는 경우도 있고 번거로움

 + 여기서 모키토를 이용한 목이 나옴
 + when ~할때 then 이런걸 리턴할거야.


## 주입

 + @Mock:  목객체생성
 + @InjectionMock : 목 객체 주입.


## 목을 올바르게 사용하기

 + 목이 프로덕션 코드의 동작을 올바르게 묘사하는가?
 + 생각하지도 못한 다른 형식으로 반환하나?
 + 예외나 널을 반환하나 ? 



# 테스트 리팩토링 - 11

 + 테스트를 좀더 명확하게 구분하기
 + 일반적인 리터럴 필드는 상수로 명확하게 어떤 것을 의미하는지 나타내주자


# 테스트 주도 개발 - 12

 + 실패하는 코드 -> 통과 -> 리팩토링 


# 까다로운 테스트

 + 스레드와 영속성을 테스트하는 접근법 


## 멀티스레드 코드 테스트 

 + 동시성 테스트 코드는 작성이 어려움 
 + 보통 이정도 같은경우는 통합테스트로 해야됨.


### 단순하고 똑똑하게 유지

 + 스레드 없이 다량의 코드를 단위 테스트 하도록 설계 
 + 그리고 남은 작은 단위 코드에대해 스레드 집중 테스트
 + 다른 사람의 작업? 믿으셈 ex) 자바5 동시성 유틸 클래

### 애플리케이션 로직 추출

 + 애플리케이션 로직과 스레드 로직이 둘다있는 메서드는  서로 분리해 줘야 된다.
 + 애플리케이션 코드를 분리하고 스레드 로직만 남겨두는대
 + 책에서는  지나치게 분리하는거 아닐까 하는 생각이 듬.



## 데이터베이스 테스트 

 + 일반적인 내용과 비슷 패스
 + 





