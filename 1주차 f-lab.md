# f-lab 1주차


1. static 으로 인한 메모리릭 현상.

# 메모리릭 이란?

필요하지도 않는 메모리를 계속 점유하고 있는 현상.

-> 더 이상 사용되지 않는 객체들이 가비지 컬렉터에 의해 회수되지 않고 계속 누적 되는 현상.

  Old 영역에 계속 누적된 객체로 인해 Major GC가 빈번하게 발생되면서 프로그램 응답 속도가 느려짐.

가바지 컬렉션에서 소멸 대상이 되는 객체가 되기위해서는 어떠한 reference변수에서 가르키지 않아야 함.


# GC가 되지 않는 참조 객체 

## Static 변수에 의한 객체 참조

static은 GC에 대상이 되지 않음.  왜냐하면 클래스가 생성될 때 메모리 할당 받고 프로그램 종료시 반환됨으로.. 사용하지않고 있어도 메모리가 할당 됨.

+ 추가  현재 자바 스레드 스택내의 지역 변수, 매개 변수에 의한 객체 참조 


## 활용법 
 
자주 사용하고 절대 변하지 않는 변수는 final static으로 선언.  < - > 반대로 자주 변하게되는 값을 static으로 사용하면 동일한 주소를 바라보게되 문제가 생김.  ex) list나 vector에 데이터가 계속 쌓이면?



# 상속을 잘못사용할시 문제점 


 1. 개방 폐쇄 원칙(캡슐화) 약화

 자식클래스는 부모클래스의 구현 사항에 의존하게 됨으로. 
 자식클래스 규칙에 어울리지않는 부모 클래스 메소드가 존재해서  부모클래스 메소드가
 자식클래스 메소드에서 동작하면, 자식 클래스의 규칙을 위반하는 결과가 발생.
 그래서 완벽한 캡슐화를 원하면 -> 상속을 포기 OR private 사용으로 인터페이스 은닉과 함께 getter , setter코드 구현 등 정확하게 상속을 구현한다.
 
 2. 설계갸 유연하지 않음 - 클래스간 결합 문제
    
 상속이란 자식클래스의 기능을 점진적으로 추가 확장이 편리함. 그러나 상속을하면 의존성(결합도 커플링) 이 생김.
 객체지향 프로그래밍에서는 결합도를 낮추고 클래스에 관련된 메소드를 넣어 해당 클래스 가 갖는 책임에 집중 (응집도 ) 단일클래스의 원칙? 
 독립성을 높여야 함. 그래서 결합도가 높으면 부모 클래스의 변경으로 자식클래스가 취약해지는 결과가 나옴, 
 상위클래스 변경시 자식클래스 검증 수정 테스트 해야됨
 

 # 결론적으로 리스코프 치환원칙의 위배 됨.

  잘못된 상속은 캡슐화의 약화, 클래스간 결합 두개의 문제의 결과물로 인해 위반됨
  
 리스코프 치환 원칙이란? -> 상위 타입을 사용하는 메소드에 하위 타입의 객체를 매개변수로 전달할 경우 정상 동작 해야됨.
                   --> 특정 메소드가 상위타입 인자로 사용한다고 할때 그 타입의 하위타입도 문제없이 동작해야되!
  ex) 직사각형 정사각형 클래스.
   직사각형은 높이만 변경되고 폭은 유지되는데 정사각형은 높이와 폭이 같은값으로 모두 바뀌어야 된다.
    정사각형 클래스가 직사각형클래스를 상속받을 경우. 직사각형 명세서를 지킬수없으므로 리스코프 치환 원칙에 위배됨.
 

# 메모리 vs 디스크

메모리 종류

레지스터 / 캐시 / 메인 메모리 / 하드디스크

처음 순서대로 가장 빠름.

