# 상속의 장점

 + 코드 재사용으로 중복 줄임
 + 확장성 증가
 + 클래스 간의 계층 관계를 구혐함으로서 다형성을 구현함


## 단점

 + 상위 클래스 구현 하위 클래스에 노출 -> 캡슐화 깨짐
 + 부모 클래스에 강하게 결합 및 의존 -> 상위클래스 구현에 따라 하위클래스 동작 달라지거나, 상위 클래스 내부구현달라짐 -> 하위클래스 오작동
 + 부모클래스의 결함도 자식클래스에게 넘어옴. (stack <-> Vector)



# 상속을 잘못사용할시 문제점 


 1. 개방 폐쇄 원칙(캡슐화) 약화

 자식클래스는 부모클래스의 구현 사항에 의존하게 됨으로. 
 자식클래스 규칙에 어울리지않는 부모 클래스 메소드가 존재해서  부모클래스 메소드가
 자식클래스 메소드에서 동작하면, 자식 클래스의 규칙을 위반하는 결과가 발생.
 그래서 완벽한 캡슐화를 원하면 -> 상속을 포기 OR private 사용으로 인터페이스 은닉과 함께 getter , setter코드 구현 등 정확하게 상속을 구현한다.
 
 2. 설계갸 유연하지 않음 - 클래스간 결합 문제
    
 상속이란 자식클래스의 기능을 점진적으로 추가 확장이 편리함. 그러나 상속을하면 의존성(결합도 커플링) 이 생김.
 객체지향 프로그래밍에서는 결합도를 낮추고 클래스에 관련된 메소드를 넣어 해당 클래스 가 갖는 책임에 집중 (응집도 ) 단일클래스의 원칙? 
 독립성을 높여야 함. 그래서 결합도가 높으면 부모 클래스의 변경으로 자식클래스가 취약해지는 결과가 나옴, 
 상위클래스 변경시 자식클래스 검증 수정 테스트 해야됨
 

 # 결론적으로 리스코프 치환원칙의 위배 됨.

  잘못된 상속은 캡슐화의 약화, 클래스간 결합 두개의 문제의 결과물로 인해 위반됨
  
 리스코프 치환 원칙이란? -> 상위 타입을 사용하는 메소드에 하위 타입의 객체를 매개변수로 전달할 경우 정상 동작 해야됨.
                   --> 특정 메소드가 상위타입 인자로 사용한다고 할때 그 타입의 하위타입도 문제없이 동작해야되!
  ex) 직사각형 정사각형 클래스.
   직사각형은 높이만 변경되고 폭은 유지되는데 정사각형은 높이와 폭이 같은값으로 모두 바뀌어야 된다.
    정사각형 클래스가 직사각형클래스를 상속받을 경우. 직사각형 명세서를 지킬수없으므로 리스코프 치환 원칙에 위배됨.

# 보완

그래서 상속 보단 컴포지션을 사용하는걸 권장한다

컴포지션이란 ? 

클래스 간에 포함(composite) 관계를 맺어주는 것
즉, 한 클래스의 멤버변수로 다른 클래스 타입의 참조 변수를 선언하는 것을 의미한다.


+ 디자인 패턴중 사용해본 전략 패턴도 컴포지션 이다.

예를 들면 상품 판매 클래스에 
생성자에 할인 정책에 대한 클래스를 참조 한다 했을 때
(할인 정책 구현 체를 퍼센트로 할지, 일정 금액을 차감해주는 정책 클래스로 쓸지 ) 구현체를 바꿀수 있기때문에 
확장에 용이하고 수정에는 막혀 있다.. 음 다시 정리 해봐야겟다일단..




ex ) 

    class Circle {
        int x;
        int y;
        int r;
    }
    
    class Point {
        int x;
        int y;
    }

## 상속인경우 (is - A) 

    class Circle extends Point {
        int r;
    }

## 컴포지션인 경우 (has - A)
    class Circle {
        Point c = new Point();
        int r;
    }


# 장점

 + 기존 클래스의 내부 구현 방식의 영향을 벗어나 -> 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향을 받지 않는다.
 + 매서드를 호출하는 방식으로 동작하기 때문에 캡슐화 깨드리지않음.
 + 변화에 유연함 

출처 : https://www.journaldev.com/1325/composition-in-java-example

[//]: # (# 메모리 vs 디스크)

[//]: # ()
[//]: # (메모리 종류)

[//]: # ()
[//]: # (레지스터 / 캐시 / 메인 메모리 / 하드디스크)

[//]: # ()
[//]: # (처음 순서대로 가장 빠름.)

[//]: # ()
