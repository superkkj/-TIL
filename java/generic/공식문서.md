# generic




## 공식문서


+ 컬렉션에서 요소를 가져올 때 Collection컬렉션에 저장된 요소 유형으로 캐스팅을 해야되는데
+ 불편하고 안전하지 않다
+ 컴파일러는 캐스트가 컬렉션의 유형과 동일한지 확인하지 않으므로 런타임에서 캐스팅이 실패 할 수 있다.

+ Generics는 컬렉션 유형을 컴파일러에 전달하여 확인할 수 있는 방법을 제공합니다.
+ 컴파일러가 컬렉션의 요소 유형을 알게 되면 컴파일러는 컬렉션을 일관되게 사용했는지 확인하고
+ 컬렉션에서 가져오는 값에 올바른 캐스트를 삽입할 수 있습니다.



    // Removes 4-letter words from c. Elements must be strings
    static void expurgate(Collection c) {
        for (Iterator i = c.iterator(); i.hasNext(); )
            if (((String) i.next()).length() == 4)
            i.remove();
    }

    // Removes the 4-letter words from c
    static void expurgate(Collection<String> c) {
        for (Iterator<String> i = c.iterator(); i.hasNext(); )
            if (i.next().length() == 4)
            i.remove();
    }

+ 제네릭을 사용한 예와 사용하지 않는 예
+ 코드 <Type>가 보이면 "of Type"로 읽으십시오.
+ 위의 선언은 " Collection of String c." 로 읽습니다.
+ 제네릭을 사용하는 코드는 더 명확하고 안전합니다. 안전하지 않은 캐스트와 많은 추가 괄호를 제거했습니다.
+ 더 중요한 것은 메서드 사양의 일부를 주석에서 서명으로 옮겼기 때문에 컴파일러는 런타임에 형식 제약 조건이 위반되지 않았는지 컴파일 시간에 확인할 수 있습니다.
+ 프로그램은 경고 없이 컴파일되기 때문에 ClassCastException런타임에 throw되지 않을 것이라고 확신할 수 있습니다.
+ 특히 대규모 프로그램에서 제네릭을 사용하면 가독성과 견고성이 향상됩니다.

+ 우리 가 유형으로 선언 하면 언제 어디서나 참을 유지 Collection<String>하는 변수에 대해 알려주고 컴파일러는 이를 보장합니다(프로그램이 경고 없이 컴파일된다고 가정).
+ 반면에 캐스트는 프로그래머가 코드의 한 지점에서 참이라고 생각하는 것을 알려주고
+ VM은 프로그래머가 런타임에만 올바른지 여부를 확인합니다.

+ 제네릭의 주요 용도는 컬렉션이지만 다른 용도도 많이 있습니다. WeakReference 및 와 같은 "홀더 클래스" ThreadLocal가 모두 생성되었습니다 .
+ 즉, 제네릭 을 사용하도록 개조되었습니다. 더 놀랍게도 클래스 Class 가 생성되었습니다. 클래스 리터럴은 이제 런타임 및 컴파일 시간 형식 정보를 모두 제공하는 형식 토큰 으로 작동합니다.
+ 이것은 getAnnotation새로운 AnnotatedElement 인터페이스의 메소드로 예시된 정적 팩토리 스타일을 가능하게 합니다:
+ <T extends Annotation> T 
+ getAnnotation(Class<T> annotationType);

+ 이것은 일반적인 방법 입니다. 다음 스니펫과 같이 해당 인수에서 유형 매개변수 의 값을 유추하고 T의 적절한 인스턴스를 반환합니다 .T
+ Author a = Othello.class.getAnnotation(Author.class);
+ 제네릭 이전에는 Annotation 결과를 Author. 또한 컴파일러가 실제 매개변수가 의 하위 클래스를 나타내는지 확인할 수 있는 방법이 없었을 것입니다 .
+ 제네릭은 유형 삭제 에 의해 구현됩니다 . 제네릭 유형 정보는 컴파일 시간에만 존재하며 그 후에 는 컴파일러에 의해 지워 집니다.
+ 이 접근 방식의 주요 장점은 매개변수화되지 않은 유형(기술적으로 원시 유형 이라고 함)을 사용하는 레거시 코드와 일반 코드 간의 완전한 상호 운용성을 제공한다는 것입니다 .
+ 주요 단점은 런타임에 매개변수 유형 정보를 사용할 수 없고 잘못 작동하는 레거시 코드와 상호 운용할 때 자동으로 생성된 캐스트가 실패할 수 있다는 것입니다.
+ 그러나 잘못 작동하는 레거시 코드와 상호 운용되는 경우에도 일반 컬렉션에 대해 런타임 형식 안전성을 보장하는 방법이 있습니다.

+ 이 java.util.Collections클래스는 런타임 유형 안전성을 보장하는 래퍼 클래스를 갖추고 있습니다.
+ 동기화되고 수정할 수 없는 래퍼와 구조가 비슷합니다. 이러한 "검사된 컬렉션 래퍼"는 디버깅에 매우 유용합니다.
+ 일부 레거시 코드가 불가사의하게 정수를 삽입하는 문자열 세트가 있다고 가정합니다 .
+ 래퍼가 없으면 집합에서 문제 요소를 읽고 자동으로 생성된 캐스트가 String실패할 때까지 문제에 대해 알 수 없습니다.
+ 이 시점에서 문제의 원인을 파악하기에는 너무 늦습니다. 그러나 선언을 대체하는 경우:
+     Set<String> s = new HashSet<String>();

+ 이 선언과 함께:
+ Set<String> s = Collections.checkedSet(new HashSet<String>(), String.class);
+ ClassCastException컬렉션은 레거시 코드가 정수를 삽입하려고 시도하는 지점에서 throw됩니다 .
+ 결과 스택 추적을 통해 문제를 진단하고 복구할 수 있습니다.
+ 가능한 모든 곳에서 제네릭을 사용해야 합니다.
+ 코드를 생성하기 위한 추가 노력은 명확성과 형식 안전성을 확보할 가치가 있습니다.
+ 일반 라이브러리를 사용하는 것은 간단하지만 일반 라이브러리를 작성하거나 기존 라이브러리를 생성하려면 약간의 전문 지식이 필요합니다.
+ 한 가지 주의 사항이 있습니다. 컴파일된 코드를 5.0 이전 가상 머신에 배포하려는 경우 제네릭(또는 다른 Tiger 기능)을 사용할 수 없습니다.


## 정리

 1. 제네릭은 주로 컬렉션에서 사용이 많이 되어진다.
 2. 제네릭으로 타입을 설정해주면 안정성과 더불어 코드가 더 명확해진다.
 3. 그리고 사용하지 않았을 때 대비 검증 코드도 없어서 코드가 더 간결하고 가독성이 높아진다.
 4. 그리고 컴파일 시점에서 타입에 대한 검증이 이루어 지기 때문에 대규모 프로젝트에서 캐스팅에 대한 예외나 오류에 대해서 안전하다.
 5. 