# 템플릿



 + 개방 폐쇄의 원칙은 : 변화의 특성이 다른 부분을 구분하고, 
 + 각각 다른 목적과 다른 이유에 의해 다른 시점에 독립적으로 변경될 효율적인 구조를 만들어 주는 것


## 템플릿

 + 성질이 다른 코드 중 변경이 거의 일어나지 않으며
 + 일정한 패턴으로 유지되는 특성을 가진 부분을
 + 자유롭게 변경되는 성질을 가진 부분으로 부터 독립 시켜서 효과적으로 활용하는 방법 




# 예외 처리

 + try-catch-final 예외를 잡기위한 구문
 + 디비 연결이나 리소스를 사용할때 사용한다.
 + 하지만 수많은 트라이 캐치 파이널문 한순간에 오타라도있으면? 코드자체적으로도 불안하고.
 + 가독성도 떨이지고 위험 요소가 많다.

## 분리와 재사용을 위한 디자인 패턴 적용


    Connection c = null; // 변하지않는부분
    PreparedStatement ps = null; // 변하지않는부분
    try

    {
        c = dataSource.getConnection(); // 변하지않는부분
        ps = c.prepareStatement("delete from users"); // 변하는 부분 


    // 아래부분 변하지않는부분
        pS.executeUpdate();} catch(
    SQLException e)

    {
        throw e;
    } finally

    {
        if (ps != null) {
            try {
                ps.close();
            } catch (SQLException e) {
            }
        }
        if (c != null) {
            try {
                c.c듯ose();
            } catch (SQLException e) {
            }
        }
    } 


## 템플릿 메서드 패턴 적용

 + 변하지 않는 부분은 슈퍼클래스에 변하는 부분은 추상메서드로 정의
 + 서브클래스에서 오버라이드해서 새롭게 정의해서 쓰자 
 + 허나 이방식은 DAO 로직마다 새로운 클래스를 만들어야되서... 문제가 많다.


    public class UserDaoDeleteAll extends UserDao (
    
            protected PreparedStatement makeStatement(Connection c) throws SQLException (PreparedStatement ps=c.prepareStatement("delete from users");
            return ps;
    
    
            }
    }

## 전략 패턴!

 + OCP를 지키면서 템플릿 메서드 패턴보다 유연하고 확장성을 뛰어나게 해보자
 + 전략 패턴을 사용해 Ps 를 리턴하는 인터페이스를 만들고
 + add , get delete 구현 클래스를 만들어 변하하는 부분에 적용 해 준다.


 + 그러나 클래스내에 구현이 되있어서 전략패턴이라 보기어려움
 + DI를 사용해 전략 패턴의 장점을 활용하자


    StatementStrategy st = new DeleteAllStatement(); -을 선정한 전략 클래스의 오브젝트 생성
    
    jdbcContextWithStatementStrategy(st);~ 컨텍스트 호출 전략 오브젝트 전달

 + 이렇게 제 3자에게 책임을 넘겨.
 

## 문제점

 + 이렇게해도 구현 메소드는 다만들어 줘야됨.
 + 그래서 로컬 클래스 를 만들어서 해결 하거나 익명 클래스등 만들어서 클래스
 + 갯수를 줄이는 방법을 소개하고 있다.

## 의존관계

 + 보통 의존성 주입은 인터페이스를 가운데 두고한다
 + 그러나 강력한 응집력이있으면 클레스 레벨에서도 사용한다
 + 포괄적인 의미로 DI를 보면 맞기때문이다. 그리고 굳이 대체해서 사용할 이유없다면 클레스레벨에서도 허용.. 236p



## 템플랏 / 콜백 (람다랑 대입시켜 생각하면 편할 )

 + 전략 패턴의 컨텍스트 : 템플릿 -> 고정된 작업 흐름을 가진 코드를 재사용
 + 익명 내부 클래스 : 콜백  -> 템플릿 안에서 호출되는 것을 목적으로 만들어진 오브젝트 ->메소드 자체를 파라미터로 전달할수 없어서 사용함 (java8에선 다르지..)
 + 익명 내부 클래스 활용 방식 -> 복잡하지만 바뀌지 안흔 ㄴ일정한 패턴을 갖는 작업의 흐름이 존재하고
 + 그중 일부만 자주 바꿔서사용하는 경우 적합.
 + 단일 메소드 인터페이스를 사용한다.