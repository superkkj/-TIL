# AOP

 + 가장 대표적인 적용대상은 선언적 트랜잭션 기능
 + 트랜잭션 경계설정 기능을 좀 더 깔끔하게. 바꾼다




## 트랜잭션 코드의 분리 


    public void upgradeLevels() throws Exception {
        TransactionStatus status = this.transactionManager
        getTransaction(new DefaultTransactionDefinition());
        try {
            upgradeLevelsInternal(); // 메소드로 따로빼준다.
            this.transactionManager.commit(status);
        } catch (Exception e) {
            this.transactionManager.rollback(status);
            throw e;

            private void upgradeLevelslnternal () (
            List < User > users = userDao.getAll(); for (User user users) 
            {
                if (canUpgradeLevel(user)){
                (upgradeLevel(user);
        }
    }

 + 메소드 분리.
 

### DI를 이용한분리

 + Client 와 service가 너무강하게 결합되잇음
 + 트랜잭션 코드를 클래스 밖으로 일단 빼버리자! 
 + Service를 인터페이스를 두고 구현체를 두개를 두었다
 + 하나는 트랜잭션 경계기능 , 다른하나는 비즈니스로직 구현
 + 트랜잭션 경계설정 구현체에 비즈니스로직을 담은 구현체 하나 트랜잭션 매니저 2개를 주입받아
 + 코드를 완성시킴.



    public class UserServiceTx implements UserService {
    UserService userService;
    PlatformTransactionManager transactionManager;

    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
        public void setUserService (UserService userService){
            this.userService = userService;
            public void add (User user){
                t his.userService.add(user);
                public void upgradeLevels () {
                    TransactionStatus status = this.transactionManager
                            .getTransaction(new DefaultTransactionDefinition());
                    try {
                        userServiκce.upgradeLevels();
                        this.transactionManager.commit(status);
                    } catch (RuntimeException e) {
                        this.transactionManager.rollback(status);
                        throw e;

                    }
                }
            }


## DI 빈을 찾을 때

 + 보통 타입으로 찾지만 같은 타입이 2개?
 + 이름을 찾는다 
 + ex) userService;

## 트랜잭션 경계설정 코드 분리의 장점

  + 비즈니스 로직은 트랜잭션 기술 신경 안써도됨.
  + 테스트 만들기 쉬워짐.


## 테스트 대상 오브젝트 고립시키기

  + 현재 userService test는 DB,mailServer,PlatformTransactionManager등
  + 많은 것에 종속되어 테스트가 진행됨
  + 그래서 다른 외부에 것들에 의존하지않고 고립된 테스트를 만들자 (불필요한 시간, 어디서문제가 발생하는지 어려우니까..)
  + 우선 디비에 저장학고 상태가 변경되는 지확인하는 목오브젝트를 만들자


## 목 프레임 워크

 + 단위 테스트를 만들기 위한 필수적 존재.
 + 하지만 목 오브젝트 만드는건 번거로운 일.

### Mockito 프레임 워크

 + 구현없이 특정 인터페이스를 구현 가능함
 + UserDao mockUserDao =mock(UserDao.class); 
 + mock() Org.mockito.Matchers 클래스에 정의된 메서드, 로컬 메서드처럼 호출 ( 이해가되지않는 부분 ?)
 + when(mockUserDao.getAll()) .thenReturn(this .users); 
 + 호출 됫을때 users 리스트를 리턴하라는 선언


### 사용법

 + 인터페이스를 통해 목 오브젝트를 만들고.
 + 리턴값이 있으면 지정해 준다, 메서드가 호출되면 예외도 던지게 가능
 + 테스트 대상 오브젝트에 DI해서 목 오브젝트가 테스트 중 사용되도록 만듬
 + 테스트 대상 오브젝트를 사용 후에 목 오브젝트의 특정 메소드가 호출됬는지 어떤값을 가지고 몇 번 호출 됫는지 검증


### 예시코드



    @Test
    public void upgradeLevels() throws Exception {
    UserServiceImpl userServiceImpl = new UserServiceImpl();
    
    UserLevelUpgradePolicy userLevelUpgradePolicy = new UserLevelUpgradePolicyImpl();
    UserDao mockUserDao = mock(UserDao.class);
    when(mockUserDao.getAll()).thenReturn(this.users);
    
    userServiceImpl.setUserDao(mockUserDao);
    userServiceImpl.setUserLevelUpgradePolicy(userLevelUpgradePolicy);
    
    userServiceImpl.upgradeLevels();
    
    verify(mockUserDao, times(2)).update(any((User.class)));
    verify(mockUserDao).update(users.get(1));
    assertThat(users.get(1).getLevel(), is(Level.SILVER));
    verify(mockUserDao).update(users.get(3));
    assertThat(users.get(3).getLevel(), is(Level.GOLD));
    }


 


# 다이내믹 프록시와 팩토리 빈

## 프록시 프록시 패턴 , 데코레이터 패턴

 + 앞서 코드를 분리할때 UserServiceTx 만들었다
 + 부가기능 + 핵심기능으로 구현체 분리
 + 하지만 핵심 기능 클래스를 직접사용하면? 부가기능이 적용이 될수 없다.
 + 프록시패턴을 이용해보자 . 
 + 타깃과 같은 인터페이스를 구현했다는 것과 프록시가 타깃을 제어 할 수 있는 위치에 있는게 특징


### 프록시 패턴 목적

 + 클라이언트가 타깃에 접근하는 방법 제어
 + 타깃에 부가적인 기능을 부여해주기 위해 . 


### 데코레이터 패턴

 + 타깃에 부가적인 기능을 런타임 시 다이나믹하게 부여해주기 프록시를 사용하는  패턴
 + 동적으로 기능을 부가한다? 컴파일 시점 에서 코드상에는 어던 방법과 순서로
 + 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다는 뜻.
 + 데코레이터 패턴에서는 같은 인터페이스를 구현한 타겟과 여러 개의 프록시를 사용 가능함.
 + 여러개인 만큼 순서정하고 단계적으로 위임하는 구조가 생성됨 .


### 예시

 + InputStream / OutputStream 구현 클래스
 + UserServiceTx (UserService 타입 오브젝트를 DI받아 기능을 위임하지만 , 트랜잭션 경계설정 기능 부여)
 + 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은채 새로운 기능을 추가 할때 좋다.



## 프록시 패턴

 + 타깃에 대한 접근방법을 제한 하려는 목적
 + 기능이나 확장하거나 추가하지않지만 접근방식을 변경해 줌.
 + 타깃오브젝트는 당장 필요하지않거나 꼭 필요한 시점까지 오브젝트를 생성하지 않는 편이 좋다.


### 다이내믹 프록시 (++ 리플렉트)

 + 기존 프록시를 직접만들면 .. 
 + 타깃 인터페이스를 구현하고 위임 코드 작성하기 번거로움. 일일이 다 만들어 줘야되니..
 + 부가기능 코드가 중복될 가능성도 많다.


### 리플렉션

 + 리플렉션 기능을 이용하며 다이내믹 프록시 만들어 줌.
 + 자바의 코드자체를 추상화해서 접근하도록 만듬


    public void invokeMethod() throws Exception {
        String name = "Spring";
        Method lengthMethod = String.class.getMethod("length");
        System.out.println(lengthMethod.invoke(name));

    }


### 프록시 클래스

 + 다이내믹 프록시를 이용한 프록시 만들기.


    Hello proxiedHello =new HelloUppercase(new HelloTarget());--

 + 문제점 : 인터페이스 모든 메서드 구현 및 , 부가기능인 리턴값을 대문자로 바꾸는 기능이 모든 메소드에 중복..


### 다이내믹 프록시 적용

 + HelloUppercase를 다이내믹 프록시로 만들자 
 + 프록시 팩토리에 의해 런타임시 다이내믹하게 만들어지는 오브젝트


![](Img/img_5.png)

 + 타깃의 인터페이스와 같은 타입으로 만들어 짐
 + 부가기능은 따로 만들어 줘야함! -> 부가기능은 InvocationHandler를 구현한 오브젝트에 담음
 + public Object invoke(Object proxy, Method method, Object[] args '
 + 다이나믹 프록시 오브젝트는 클라이언트의 모든 요청을 리플렉션 정보로 변환해 InvocationHandler 구현 오브젝트의 invoke() 메소드에 넘김
 + InvocationHandler 구현 오브젝트가 타깃 오브젝트 레퍼런스를 가지고 있으면 리플렉션을 통해 간단한 위임코드 가능.
 + 

![](Img/img_6.png)


 + Hello 인터페이스를 제공하면서 프록시 팩토리에게 다이내믹 프록시를 만들어달라고 요청하면 Hello 인터페이스의 모든 메소드를 구현한 오브젝트를 생성해준다.
 + InvocationHandler 인터페이스를 구현한 오브젝트를 제공해주면 다이내믹 프록시가받는 모든 요청을 InvocationHandler의 invoke() 메소드로 보내준다. 
 + Hello 인터페이스의 메소드가 아무리 많더라도 invoke() 메소드 하나로 처리할 수 있다.



    public class UppercaseHandler implements InvocationHandler {

        private final Hello target;
    
        public UppercaseHandler(Hello target) {
            this.target = target;
        }
    
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            Object result =  method.invoke(target, args);
            if (result instanceof String) {
                return ((String) result).toUpperCase();
            }
            return result;
        }
    }

 + InvocationHandler를 사용하고 Hello 인터페이스를 구현하는 프록시


    Hello proxiedHello = (Hello) Proxy.newProxyInstance(getClass().getClassLoader(),
    new Class[]{Hello.class},
    new UppercaseHandler(new HelloTarget()));

 + 구현 


### 다이내믹 프록시 확장

 + 타깃의 종류에 상관없이 적용이 가능함
 + 위 Hello - >     private final Object target;


## 다이내믹 프록시를 위한 팩토리 빈

 + 동적 프록시 오브젝트는 스프링 빈 등록 방법 X
 + 스프링은 지정된 클래스 이름을 가지고 리플렉션을 이용해 해당 클래스의 오브젝트 만듬
 + 스프링은 내부적으로 리플렉션 API를 이용해 빈 정의에 나오는 클래스 이름을 가지고 빈 오브젝트 생성.
 + 클래스 자체를 내부적으로 동적으로 새로 정의해서 사용하기 때문에 동적 프록시 오브젝트는 생성 되지 안흥ㅁ 빈으로.
 + 오로지 Proxy 클래스의 newProxyInstance()라는 스태틱 팩토리 메소드를 통해 만듬


### 팩토리 빈

  + 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 맏늘어진 특별한 빈
  + 스프링은 클래스 정보가지고 디폴트 생성자를 통해 오브젝트를 만드는 법이외에 다양한 방법 제공 
  + 대표적으론 팩토리 빈을 이용한 빈 생성 


    public interface FactoryBean<T> {
        @Nullable
        T getObject() throws Exception;
        @Nullable
        Class<?> getObjectType();
        default boolean isSingleton() {
        return true;
        }
    }

 + 스프링은 FactoryBean 인터페이스를 구현한 클래스가 빈의 클래스로 지정되면, 팩토리 빈 클래스의
 + getObject() 메소드를 이용해 오브젝트를 가져오고 , 이를 빈 오브젝트로 활용
 + 빈 오브젝트를 생성하는 과정에만 사용됨

### 다이내믹 프록시를 만들어 주는 팩토리 빈

 + 팩토리 빈을 사용해 동적 프록시 오브젝트를 스프링 빈으로 만들어 줄수 있따


## 프록시 팩토리 빈 방식 장점 한계

### 프록시 팩토리 빈의 재사용

 + 하나 이상의 팩토리 빈을 동시에 여러개 등록해도 상관 X -> 팩토리 빈이기 때문에 각 빈의 타입은 타깃 인터페이스와 일치한다.
 + 프록시 팩토리 빈을 이용하면 프록시 기법을 아주 빠르고 효과적으로 적용할 수 있다.


### 프록시 팩토리 빈 방식 장점

 + 다이내믹 프록시를 이용하면 타깃 인터페이스를 구현하는 클래스를 일일이 만드는 번거로움을 제거할 수 있다.
 + 하나의 핸들러 메소드를 구현하는 것만으로도 수많은 메소드에 부가기능을 부여 해줄 수 있으니 부가기능 코드의 중복 문제도 사라진다.



### 한계

 + 프록시를 통해 타깃에 부가기능을 제공하는 것은 메소드 단위로 일어나는 일이다. 하나의 클래스 안에 존재하는 여러개의 메소드에 부가기능을 한 번에 제공하는 건 어렵지 않게 가능했다.
 + 하지만 한 번에 여러 개의 클래스에 공통적인 부가기능을 제공하는 일은 지금까지 살펴본 방법으로는 불가능하다.

 + 하나의 타깃 오브젝트에만 부여되는 부가기능이라면 상관없겠지만, 트랜잭션과 같이 비즈니스 로직을 담은 많은 클래스의 메소드에 적용할 필요가 있다면
 + 거의 비슷한 프록시 팩토리 빈의 설정이 중복되는 것을 막을 수 없다.

## 스프링의 프록시 팩토리 빈

 + 스프링은 트랜잭션 기술과 메일 발송 기술에 적용했던 서비스 추상화를 프록시 기술에도 동일하게 적용하고 있다.
 + 스프링에선 일관된 방법으로 프록시를 만들어주는 추상 레이어를 제공하는데
 + 프록시 오브젝트를 생성해주는 기술을 추상화한 팩토리 빈 제공
 + ProxyFactoryBean 프록시를 생성해 빈 오브젝트로 등록해줌
 + 순수하게 프록시만 생성 작업 담당 , 프록시를 통해 제공해줄 부가기능은 별도의 빈에 둠.
 + ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능은 Methodlnterceptor 인터페이스를 구현해서 만든다. 
 + Methodlnterceptor는 InvocationHandler와 비슷하지만 한 가지 다른 점이 있다.
 + InvocationHandler의 invoke() 메소드는 타깃 오브젝트에 대한 정보를 제공하지 않는다. 따라서 타깃은 InvocationHandler를 구현한 클래스가 직접 알고 있어야 한다.
 + Methodlnterceptor의 invoke() 메소드는 ProxyFactoryBean으로부터 타깃 오브젝트에 대한 정보까지도 함께 제공받는다.
 + Methodlnterceptor는 타깃 오브젝트에 상관없이 독립적으로 만들어질 수 있다.




    @Test
    public void proxyFactoryBean() {
        ProxyFactoryBean pfBean =new ProxyFactoryBean();
        pfBean.setTarget(new HelloTarget());
        pfBean.addAdvice(new UpperCaseAdvice());
        
            Hello proxiedHello = (Hello) pfBean.getObject();
            assertThat(proxiedHello.sayHi("gunju"), is("HI GUNJU"));
    }

    private class UpperCaseAdvice implements MethodInterceptor {
                @Override
                public Object invoke(MethodInvocation invocation) throws Throwable {
                Object result = invocation.proceed();
                if (result instanceof String) {
                return ((String) result).toUpperCase();
                }
            return result;
        }
    }


## 어드바이스 : 타깃이 필요 없는 순수한 부가기능

 + Methodlnterceptor를 구현한 UppercaseAdvice에는 타깃 오브젝트가 등장하지 않는다. 
 + Methodlnterceptor로는 메 소드 정보와 함께 타깃 오브젝트가 담긴 Methodlnvocation 오브젝트가 전달된다.



