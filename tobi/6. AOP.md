# AOP

 + 가장 대표적인 적용대상은 선언적 트랜잭션 기능
 + 트랜잭션 경계설정 기능을 좀 더 깔끔하게. 바꾼다




## 트랜잭션 코드의 분리 


    public void upgradeLevels() throws Exception {
        TransactionStatus status = this.transactionManager
        getTransaction(new DefaultTransactionDefinition());
        try {
            upgradeLevelsInternal(); // 메소드로 따로빼준다.
            this.transactionManager.commit(status);
        } catch (Exception e) {
            this.transactionManager.rollback(status);
            throw e;

            private void upgradeLevelslnternal () (
            List < User > users = userDao.getAll(); for (User user users) 
            {
                if (canUpgradeLevel(user)){
                (upgradeLevel(user);
        }
    }

 + 메소드 분리.
 

### DI를 이용한분리

 + Client 와 service가 너무강하게 결합되잇음
 + Service를 인터페이스를 두고 구현체를 두개를 두었다
 + 하나는 트랜잭션 경계기능 , 다른하나는 비즈니스로직 구현
 + 트랜잭션 경계설정 구현체에 비즈니스로직을 담은 구현체 하나 트랜잭션 매니저 2개를 주입받아
 + 코드를 완성시킴.



    public class UserServiceTx implements UserService {
    UserService userService;
    PlatformTransactionManager transactionManager;

    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
        public void setUserService (UserService userService){
            this.userService = userService;
            public void add (User user){
                t his.userService.add(user);
                public void upgradeLevels () {
                    TransactionStatus status = this.transactionManager
                            .getTransaction(new DefaultTransactionDefinition());
                    try {
                        userServiκce.upgradeLevels();
                        this.transactionManager.commit(status);
                    } catch (RuntimeException e) {
                        this.transactionManager.rollback(status);
                        throw e;

                    }
                }
            }


## DI 빈을 찾을 때

 + 보통 타입으로 찾지만 같은 타입이 2개?
 + 이름을 찾는다 
 + ex) userService;

## 트랜잭션 경계설정 코드 분리의 장점

  + 비즈니스 로직은 트랜잭션 기술 신경 안써도됨.
  + 테스트 만들기 쉬워짐.


## 테스트 대상 오브젝트 고립시키기

  + 현재 userService test는 DB,mailServer,PlatformTransactionManager등
  + 많은 것에 종속되어 테스트가 진행됨
  + 그래서 다른 외부에 것들에 의존하지않고 고립된 테스트를 만들자 (불필요한 시간, 어디서문제가 발생하는지 어려우니까..)
  + 우선 디비에 저장학고 상태가 변경되는 지확인하는 목오브젝트를 만들자


## 